{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Script Foundation and Prerequisite Checks",
        "description": "Create the main wail2ban.ps1 script file. Implement initial checks to ensure the script is run with administrative privileges and that the PowerShell execution policy is sufficient.",
        "details": "The script should verify it's running in an elevated session. A check for PowerShell version 5.1+ should also be included. Use `([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)` for the admin check.",
        "testStrategy": "Run the script as a standard user to verify the admin check fails with a clear message. Run as admin to verify it passes. Test on a system with a 'Restricted' execution policy to ensure it exits gracefully.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Configuration via Script Variables",
        "description": "Centralize all user-configurable settings into a variables block at the top of the script. Include settings for event IDs, failure threshold, ban duration, time window, and log file path.",
        "details": "Create a well-commented section at the top of wail2ban.ps1 with clearly named variables, e.g., `$EventIDsToMonitor`, `$MaxFailedAttempts`, `$BanTimeMinutes`, `$WhitelistIPs`. This fulfills the MVP requirement for basic configuration.",
        "testStrategy": "Modify the configuration variables (e.g., lower the failure threshold) and restart the script. Verify that the new settings are being used by the script's logic once other components are built.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Core Event Log Monitoring",
        "description": "Develop the core logic to query Windows Event Logs (Application, Security, System) for specific event IDs based on the script's configuration.",
        "details": "Use `Get-WinEvent` with a `-FilterHashtable` for efficient querying. The function should be able to handle multiple log names and event IDs provided in the configuration variables.",
        "testStrategy": "Generate fake failed login events (e.g., using RDP with wrong credentials) and verify the script can detect and read them. Test with both valid and invalid event IDs to ensure robustness.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Develop IP Extraction and Tracking Logic",
        "description": "Implement functionality to parse event log messages to extract the offending IP address. Create an in-memory data structure to track the count of failed attempts and timestamps for each IP.",
        "details": "Use a robust regex pattern to find IPv4 addresses in the event message text. A PowerShell Hashtable of the form `@{ 'IP_Address' = @{ 'Count' = 1; 'Timestamps' = @(Get-Date) } }` can be used for tracking.",
        "testStrategy": "Feed the parsing function with various sample event log messages (including ones without IPs) to ensure correct extraction and graceful failure. Verify the tracking hashtable is updated correctly after multiple attempts from the same IP.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement IP Banning via Windows Firewall",
        "description": "Create a function that uses the `netsh` command-line tool to create a new inbound firewall rule to block a specific IP address. The rule should have a consistent naming convention for easy identification.",
        "details": "The function will execute `netsh advfirewall firewall add rule name=\"wail2ban-Block-IP\" dir=in action=block remoteip=\"IP_ADDRESS\"`. It should also include logic to handle rule removal.",
        "testStrategy": "Call the function with a test IP address and verify the rule is created in the Windows Defender Firewall control panel. Test the corresponding removal function and verify the rule is deleted.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Integrate Banning Logic with IP Tracking",
        "description": "Combine the IP tracking and firewall banning components. When an IP's attempt count exceeds the configured threshold within the specified time window, the script should automatically call the ban function.",
        "details": "The main script loop will iterate through events, update the IP tracking hashtable, and check if `IP.Count >= $MaxFailedAttempts` within the `$TimeWindow`. If true, trigger the ban.",
        "testStrategy": "Simulate multiple failed attempts from a single IP in quick succession. Verify that the IP is banned only after the threshold is crossed. Verify that attempts outside the time window do not trigger a ban.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Basic Whitelist Functionality",
        "description": "Add a configurable array of IP addresses that should never be banned. The banning logic must check an IP against this whitelist before creating a firewall rule.",
        "details": "The whitelist will be defined in the configuration section (Task 2). Before calling the ban function, the script will check if the target IP is present in the `$WhitelistIPs` array.",
        "testStrategy": "Add a test IP to the whitelist variable. Simulate failed attempts from this IP that exceed the ban threshold. Verify that the IP is NOT banned and that a log entry may be created to indicate the whitelisted attempt.",
        "priority": "medium",
        "dependencies": [
          2,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Action Logging to File",
        "description": "Create a centralized logging function that writes all significant actions (e.g., IP banned, IP unbanned, whitelisted attempt detected) to a structured text file for auditing.",
        "details": "The log format should be `[Timestamp] Action: IP - Reason`. For example: `[2023-10-27 10:30:00] BAN: 192.168.1.100 - Exceeded 5 failed login attempts.` Use `Add-Content` to append to the log file specified in the configuration.",
        "testStrategy": "Run the script and perform actions that trigger bans. Check the log file to ensure the entries are created correctly with the right format, timestamp, and details.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Develop Ban Management Command-Line Interface",
        "description": "Implement command-line parameters to allow users to manage bans. This includes options to list all currently banned IPs, unban a specific IP, and clear all bans created by the script.",
        "details": "Use a `param()` block to define switches like `-ListBans`, `-UnbanIP <string>`, and `-ClearAllBans`. These parameters will trigger functions that interact with `netsh` to list or delete rules matching the script's naming convention.",
        "testStrategy": "Manually ban a few IPs using the script's main function. Then, run the script with `-ListBans` and verify the output. Run with `-UnbanIP` and check that the specific rule is gone. Run with `-ClearAllBans` and confirm all script-related rules are removed.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Create Embedded Comment-Based Help",
        "description": "Write comprehensive, comment-based help for the script that is accessible via `Get-Help`. Include a synopsis, detailed description, parameter explanations, and usage examples.",
        "details": "Use standard PowerShell help keywords like `.SYNOPSIS`, `.DESCRIPTION`, `.PARAMETER`, `.EXAMPLE`, and `.NOTES` at the beginning of the script file.",
        "testStrategy": "In a PowerShell console, run `Get-Help .\\wail2ban.ps1 -Full` and verify that all sections of the help content are displayed correctly, are well-formatted, and are easy to understand.",
        "priority": "low",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Correct `_TrackIP` Logic to Use a Sliding Time Window for Ban Evaluation",
        "description": "Refactor the `_TrackIP` function to accurately count failed login attempts within a sliding time window (`$CHECK_WINDOW`). The current logic is flawed and can be evaded. The new implementation should add the timestamp of a new attempt *before* evaluating the ban condition. The check for `$CHECK_COUNT` must be performed against a list of all attempts that have occurred within the last `$CHECK_WINDOW` seconds from the current time. After the check, expired timestamps should be purged to manage memory.",
        "status": "pending",
        "dependencies": [
          2,
          6
        ],
        "priority": "medium",
        "details": "The `_TrackIP` function's logic must be changed to the following sequence to ensure accurate sliding window evaluation:\n1. Add the timestamp of the new failed attempt to the IP's history array.\n2. Create a temporary, filtered list of all timestamps for that IP that fall within the configured `$CHECK_WINDOW` (e.g., `[System.DateTime]::UtcNow.AddSeconds(-$CHECK_WINDOW)`).\n3. Compare the count of this temporary, filtered list against `$CHECK_COUNT`.\n4. If the count meets or exceeds the threshold, trigger the ban action.\n5. After the evaluation is complete, the function can then proceed to clean up timestamps from the master tracking object that are older than the time window. This separation of evaluation and cleanup logic is critical to fixing the evasion flaw.",
        "testStrategy": "Set a low threshold (e.g., `$CHECK_COUNT = 3`) and a short time window (e.g., `$CHECK_WINDOW = 60` seconds).\n1. **Test Ban Evasion Fix:** Generate two attempts at T=0s and T=30s. Then, at T=70s, generate a third attempt. The correct logic should evaluate only the attempts within the last 60 seconds (from T=10s to T=70s), which are the attempts at T=30s and T=70s. The count is 2, so no ban is issued. This confirms the sliding window works correctly and old attempts are properly ignored for the check.\n2. **Test Normal Expiration:** Generate two attempts (at T=0s, T=5s). Wait 70 seconds. Generate a third attempt at T=75s. The IP should NOT be banned, as the first two attempts have expired and are outside the current 60-second window.\n3. **Test Standard Ban:** Generate three attempts in rapid succession (e.g., at T=0s, T=5s, T=10s). The IP should be banned immediately on the third attempt, as all three fall within the 60-second window.",
        "subtasks": [
          {
            "id": 1,
            "title": "Append New Timestamp Before Evaluation",
            "description": "Modify the `_TrackIP` function to add the current UTC timestamp of a new failed attempt to the corresponding IP's history array. This action must be the first step performed on the tracking object to ensure the new attempt is included in the subsequent evaluation.",
            "dependencies": [],
            "details": "The first line of logic operating on the IP's data in `_TrackIP` should be to append `[System.DateTime]::UtcNow` to its timestamp list. This ensures the sliding window calculation is always based on the most up-to-date data.",
            "status": "pending",
            "testStrategy": "After a single simulated failed attempt, inspect the in-memory tracking object to confirm the new timestamp has been successfully added to the correct IP's list."
          },
          {
            "id": 2,
            "title": "Filter Timestamps into a Temporary List for the Sliding Window",
            "description": "Implement logic to create a temporary, in-memory list of timestamps for the given IP that fall within the `$CHECK_WINDOW`. This list will be used exclusively for the ban evaluation.",
            "dependencies": [
              "11.1"
            ],
            "details": "Use a `Where-Object` filter on the IP's full timestamp array. The filter condition should select all timestamps greater than or equal to the calculated window start time (`[System.DateTime]::UtcNow.AddSeconds(-$CHECK_WINDOW)`).",
            "status": "pending",
            "testStrategy": "Manually populate an IP's timestamp array with entries both inside and outside the `$CHECK_WINDOW`. Execute the filter and assert that the resulting temporary list contains only the recent timestamps."
          },
          {
            "id": 3,
            "title": "Evaluate Ban Condition Using the Filtered List Count",
            "description": "Compare the count of the temporary, filtered timestamp list against the `$CHECK_COUNT` configuration variable. This check will determine if the ban threshold has been met or exceeded within the sliding window.",
            "dependencies": [
              "11.2"
            ],
            "details": "Use an `if` statement to check if the `.Count` property of the temporary list created in the previous subtask is greater than or equal to `$CHECK_COUNT`.",
            "status": "pending",
            "testStrategy": "Set `$CHECK_COUNT` to 3. Test with a filtered list containing 2 items and verify the condition is false. Test again with a list containing 3 items and verify the condition is true."
          },
          {
            "id": 4,
            "title": "Trigger Ban Action if Threshold is Met",
            "description": "If the evaluation condition is met, call the appropriate function to initiate the IP ban process (which includes checking the whitelist and creating the firewall rule).",
            "dependencies": [
              "11.3"
            ],
            "details": "Place the call to the existing ban function inside the `if` block from the previous subtask. Ensure the IP address is passed as an argument.",
            "status": "pending",
            "testStrategy": "Simulate enough failed attempts from a non-whitelisted IP to meet the threshold. Verify that the ban function is invoked, for example, by checking for the creation of a new firewall rule."
          },
          {
            "id": 5,
            "title": "Purge Expired Timestamps from the Master Tracking Object",
            "description": "After the ban evaluation is complete (whether a ban was triggered or not), implement a cleanup step to remove all timestamps from the IP's master history list that are older than the `$CHECK_WINDOW`.",
            "dependencies": [
              "11.3"
            ],
            "details": "This logic should execute after the `if` block for the ban check. Re-assign the IP's timestamp list in the master tracking object to a filtered version of itself, keeping only the timestamps that fall within the current window. This prevents the list from growing indefinitely.",
            "status": "pending",
            "testStrategy": "Simulate several attempts, wait for some to become older than `$CHECK_WINDOW`, then trigger a new attempt. After the function runs, inspect the master tracking object and verify that the expired timestamps have been removed."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-31T12:15:37.015Z",
      "updated": "2025-08-01T05:37:55.883Z",
      "description": "Tasks for master context"
    }
  }
}